// Sudoku.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//

#include <iostream>
#include <vector>
#include <algorithm>

class Solution {
public:
    void solveSudoku(std::vector<std::vector<char>>& board) {
        std::vector<int> just_vec;              // вектор для заполнения board_(доска из интов, а не чаров ведь удобнее)                              
        for (int i = 0; i < 9; i++) {           // пробегаемся по всем полям доски
            board_.push_back(just_vec);         // заполняем board_ - приватное поле класса Solution
            for (int j = 0; j < 9; j++) {       //
                if (board[i][j] == '.') {       // 
                    board_[i].push_back(0);     // вместо точек кладем нули
                }
                else {                         
                    board_[i].push_back(board[i][j] - '0');     // на место чаров в board кладем в board_ соответствующие инты
                }
            }
        }
        if (backTrack()) {                                // Если функция поиска решения вернула true - значит board_ успешно заполнена и можно переносить результат в board 
            for (int x = 0; x < 9; ++x) {                 //  пробегаемся по всем полям board_
                for (int y = 0; y < 9; ++y) {             //
                    board[x][y] = board_[x][y] + '0';     // заполняем board чарами, соответсвующими числам из board_
                }
            }
        }
    }

private:

    void printBoard() {       // эта функция удобна для тестирования, чтобы выводить состояние доски
        for (int x = 0; x < 9; ++x) {
            for (int y = 0; y < 9; ++y) {
                std::cout << board_[x][y] << ' ';
            }
            std::cout << '\n';
        }
    }

    bool backTrack() {
        std::vector<int> possible_digits;     // вектор, который будет хранить числа, которые можно поставить в рассматриваемые клетки
        int min_x_variants = -1;              // координата клетки по иксу с наименьшим количеством вариантов чисел, которые в ней могут быть прямо сейчас 
        int min_y_variants = -1;              // координата клетки по игреку с наименьшим количеством вариантов чисел, которые в ней могут быть прямо сейчас
        int min_variants = 10;                // количество вариантов чисел в клетке с наименьшим количество вариантов чисел
        for (int x = 0; x < 9; ++x) {         // пробегаемся по доске, хотим найти клетку для которой меньше всего вариантов заполнения
            for (int y = 0; y < 9; ++y) {     //
                if (board_[x][y] == 0) {      // если клетку ещё не рассматривали      
                    possible_digits = get_possible_digits(x, y);      // получаем вектор чисел, которые в ней могут находиться
                    int variants_number = possible_digits.size();     // variants_number - кол-во чисел, которые могут находиться в данной клетке
                    if (variants_number == 0) {                       // если при предыдущих шагах алгоритма мы заблокировали возможность корректно заполнить данную клетку,
                        return false;                                 // то надо откатиться на шаг назад, сообщив, что последний шаг алгоритма привел нас в тупик
                    }
                    if (variants_number < min_variants) {     // если вариантов заполнения данной клетки наименьшее число среди рассмотренных ранее в цикле клеток 
                        min_x_variants = x;                   // значит надо обновить min_x_variants, min_y_variants и min_variants
                        min_y_variants = y;                   // 
                        min_variants = variants_number;       //
                    }
                }
            }
        }
        if (min_x_variants == -1) {     // если все клетки уже были рассмотрены(пустых мест нет)
            return true;                // возвращаем сообщение об успешном заполнении всеё доски
        }
        possible_digits = get_possible_digits(min_x_variants, min_y_variants);     // получаем вектор возможных чисел для клетки с наименьшим числов вариантов заполнения
        for (int digit : possible_digits) {                                        // пробегаемся по всем этим вариантам
            board_[min_x_variants][min_y_variants] = digit;                        // ставим в клетку рассматриваемую цифру
            if (backTrack()) {                                                     // запускаем backTrack снова, но теперь на доске рассматриваемая клетка уже занята
                return true;                                                       // Если доску в дальнейшем удалось успешно заполнить, проталкиваем true дальше
            }   
        }
        board_[min_x_variants][min_y_variants] = 0;     // Возвращаем прежнее значение рассматриваемой клетки
        return false;                                   // Если ни один из вариантов не подошел для заполнения клетки, надо откатиться на шаг назад
    }

    std::vector<int> get_possible_digits(int x, int y) {     // функция выдает возможные варианты для клетки с координатми х и у
        std::vector<int> possible_variants(10, 1);           // в векторе possible_variants позиция i равна единице, если значение i допустимо в клетке прямо сейчас, 0 - иначе
        for (int i = 0; i < 9; ++i) {                        // 
            possible_variants[board_[x][i]] = 0;             // ставим 0 для чисел, которые встречаются в том же столбце, что и наша клетка
            possible_variants[board_[i][y]] = 0;             // ставим 0 для чисел, которые встречаются в той же строке, что и наша клетка
        }
        int square_x_begin = x / 3 * 3;                      // координата по х начала квадрата, содержащего нашу клетку
        int square_y_begin = y / 3 * 3;                      // координата по у начала квадрата, содержащего нашу клетку
        for (int i = square_x_begin; i < square_x_begin + 3; ++i) {         // пробегаемся по всем клеткам квадрата, содержащего нашу клетку
            for (int j = square_y_begin; j < square_y_begin + 3; ++j) {     //
                possible_variants[board_[i][j]] = 0;                        // ставим 0 для чисел, которые встречаются в том же квадрате, что и наша клетка
            }
        }
        std::vector<int> possible_digits;              // вектор будет хранить список всех возможных вариантов цифр для нашей клетки
        for (int digit = 1; digit <= 9; ++digit) {     //
            if (possible_variants[digit] == 1) {       // если стоит 1, значит ни в столбце, ни в строке, ни в квадрате digit не встретилась
                possible_digits.push_back(digit);      // кладем digit в список возможных вариантов для клетки
            }
        }
        return possible_digits;                        // возвращаем что просили
    }

    std::vector<std::vector<int>> board_;     // аналог board, но вместо чаров стоят числа, вместо точек - нули.
};

//тестовая часть
/*int main()
{
    std::vector<std::vector<char>> board {
        {'5','3','.','.','7','.','.','.','.'} , {'6','.','.','1','9','5','.','.','.'},
        {'.','9','8','.','.','.','.','6','.' }, { '8','.','.','.','6','.','.','.','3' },
        {'4','.','.','8','.','3','.','.','1'},{'7','.','.','.','2','.','.','.','6'},
        {'.','6','.','.','.','.','2','8','.'},{'.','.','.','4','1','9','.','.','5'},
        {'.','.','.','.','8','.','.','7','9' }
        };

    Solution S;
    S.solveSudoku(board);
    return 0;
}*/
